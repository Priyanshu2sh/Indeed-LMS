{% extends "base.html" %} {% block content %}

<style>
  /* Disable scroll everywhere */
  html,
  body {
    height: 100%;
    margin: 0;
    padding: 0;
    overflow: hidden !important;
  }

  /* Disable base file buttons */
  .btn,
  button {
    pointer-events: none;
    opacity: 0.5;
  }

  /* Fullscreen countdown overlay */
  #countdown-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.9);
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    color: #fff;
    font-size: 2rem;
    z-index: 9999;
  }

  /* Chat container */
  .chat-container {
    height: 80vh;
    display: flex;
    flex-direction: column;
    padding-bottom: 20vh;
  }

  /* Chat box (main area) */
  #chat-box {
    flex: 1;
    overflow-y: auto;
    border: 1px solid #ddd;
    border-radius: 10px;
    padding: 15px;
    background: #fff;
    position: relative; /* only for internal positioning */
  }

  .message {
    margin-bottom: 15px;
  }
  .bot {
    font-weight: bold;
    color: #0d6efd;
  }
  .user {
    font-weight: bold;
    color: #198754;
  }

  /* Camera fixed exactly at bottom-right inside chat-box */
  #camera {
    width: 200px;
    height: 150px;
    background: #000;
    border-radius: 10px;
    overflow: hidden;
    position: fixed;
    bottom: 20px;
    right: 20px;
    box-shadow: 0px 2px 10px rgba(0, 0, 0, 0.4);
    z-index: 1000;
  }

  #camera video {
    width: 100%;
    height: 100%;
    object-fit: cover;
  }

  .main-screen {
    text-align: center;
  }

  #mic-container {
    position: absolute;
    bottom: 7%;
    left: 50%;
    transform: translateX(-50%);
  }

  #mic-btn {
    background: #007bff;
    border: none;
    border-radius: 50%;
    padding: 15px;
    cursor: pointer;
    color: white;
    font-size: 20px;
    box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
  }

  #mic-btn:focus {
    outline: none;
  }

  #mic-icon {
    font-size: 22px;
  }

  .shape-left {
    left: 0;
    max-width: 0;
    overflow: hidden;
  }

  .message {
    display: flex;
    margin-bottom: 15px;
  }

  .message.question {
    justify-content: flex-start;
  }

  .message.answer {
    justify-content: flex-end;
  }

  .bubble {
    max-width: 70%;
    padding: 10px 15px;
    border-radius: 15px;
    word-wrap: break-word;
  }

  .bubble.question {
    background: #f1f1f1;
    color: #333;
    border-bottom-left-radius: 0;
  }

  .bubble.answer {
    background: #0d6efd;
    color: white;
    border-bottom-right-radius: 0;
  }
</style>

<!-- Countdown Overlay -->
<div id="countdown-overlay">
  <div id="countdown-message">
    Your interview will start in <span id="countdown">5</span> sec
  </div>
</div>


<div class="main-screen container mt-4 chat-container">
  <!-- Add this somewhere in interview_page.html (e.g. near header) -->
  <div style="margin-bottom: 10px;">
    <div id="demo-timer" style="
        background: #e48484;
        color: #fff;
        padding: 6px 12px;
        border-radius: 6px;
        font-weight: 600;
        display: none;
        width: fit-content;      /* Auto width */
    ">
      Time left: <span id="time-left">--:--</span>
    </div>
  </div>

  <!-- Heading -->
  <h3 class="mb-3">Practice Interview</h3>

  <!-- Chat Area -->
  <div id="chat-box"></div>
  <!-- Camera attached inside -->
  <div id="camera">
    <video id="video" autoplay muted></video>
  </div>

  <!-- Mic button bottom center -->
  <div id="mic-container">
    <button id="mic-btn">
      <i id="mic-icon" class="fas fa-microphone"></i>
    </button>
  </div>
</div>

<!-- Summary Modal -->
<div id="summaryModal" style="
  position: fixed; top: 0; left: 0; width: 100%; height: 100%;
  background: rgba(0,0,0,0.5); display: none; justify-content: center; align-items: center;
  z-index: 9999;
">
  <div style="
    background: #fff;
    width: 60%;
    padding: 20px;
    border-radius: 8px;
    max-height: 80%;
    overflow-y: auto;
    position: relative;
  ">
    <h2>Interview Result Summary</h2>

    <div id="summaryContent"></div>
  </div>
</div>


<script>
  // === Camera & Mic Access ===
  navigator.mediaDevices
    .getUserMedia({ video: true, audio: true }) // ask for both
    .then((stream) => {
      // Attach camera stream to video element
      document.getElementById("video").srcObject = stream;

      // Save mic track but mute initially (control mic ON/OFF manually later)
      window.localStream = stream;
      window.audioTrack = stream.getAudioTracks()[0];
      if (window.audioTrack) {
        window.audioTrack.enabled = false; // keep mic OFF by default
        console.log("Mic access granted but OFF initially");
      }
    })
    .catch((err) => console.error("Camera/Mic access denied:", err));

  // === Countdown Overlay ===
  let countdown = 5;
  const countdownElement = document.getElementById("countdown");
  const overlay = document.getElementById("countdown-overlay");

  const timer = setInterval(() => {
    countdown--;
    countdownElement.textContent = countdown;
    if (countdown <= 0) {
      clearInterval(timer);
      overlay.style.display = "none"; // Hide overlay
      // TODO: Connect websocket here
      connectWebSocket();
    }
  }, 1000);
</script>

<script>
  function openSummaryModal(summaryHTML) {
    document.getElementById("summaryContent").innerHTML = summaryHTML;
    document.getElementById("summaryModal").style.display = "flex";
  }

  function closeSummaryModal() {
    console.log("Closing summary modal");
    document.getElementById("summaryModal").style.display = "none";
  }

  let socket = null;
  let micIcon = document.getElementById("mic-icon");
  let demoRemaining = 0;
  let timerEl = null;
  let timeLeftEl = null;
  let timerStarted = false;

  // Called whenever backend sends an updated remaining time
  function updateTimerDisplay(seconds) {
    if (!timerEl || !timeLeftEl) {
      timerEl = document.getElementById("demo-timer");
      timeLeftEl = document.getElementById("time-left");
    }

    if (!timerEl || !timeLeftEl) return;

    if (seconds <= 0) {
      timerEl.style.display = "none";
      return;
    }

    const minutes = Math.floor(seconds / 60);
    const remSeconds = seconds % 60;
    timerEl.style.display = "block";
    timeLeftEl.textContent = `${String(minutes).padStart(2, '0')}:${String(remSeconds).padStart(2, '0')}`;
  }

  function connectWebSocket() {
    // Replace this with your actual backend WebSocket endpoint
    const wsUrl = "{{ chat_socket_url }}";

    socket = new WebSocket(wsUrl);

    socket.onopen = function () {
      console.log("‚úÖ WebSocket connected");
    };

    socket.onmessage = function (event) {
      const data = JSON.parse(event.data);
      console.log("üì© Message from server:", data);

      if (data.error === "No demo/paid time available. Please purchase or contact admin.") {
        alert(data.error);
        window.location.href = "/interview-practice";  // Redirect to subscription/purchase page
        return;
      }

      // üïí Handle time update
      if (data.type === "time_update" && typeof data.remaining_seconds !== "undefined") {
        demoRemaining = parseInt(data.remaining_seconds, 10);
        updateTimerDisplay(demoRemaining);
      }

      // ‚è∞ Handle time expiration
      if (data.type === "time_expired") {
        console.log("‚è∞ Time expired message received");
        alert(data.message || "Your demo/paid session has ended.");

        try { stopMic(); } catch (e) { console.warn("stopMic() not defined:", e); }
      }

      if (data.type === "session_complete" && data.summary) {
        const s = data.summary;
        try { socket.close(); } catch(e){}

        const html = `
          <div style="font-family: Arial, sans-serif; line-height: 1.5;">
            
            <h3>Candidate Details</h3>
            <p><strong>Name:</strong> ${s.candidate_details.name}</p>
            <p><strong>Interview Mode:</strong> ${s.candidate_details.interview_mode}</p>
            <p><strong>Difficulty:</strong> ${s.candidate_details.difficulty_level}</p>
            <p><strong>Date & Time:</strong> ${s.candidate_details.date_time}</p>

            <hr>

            <h3>Interview Summary</h3>
            <p><strong>Total Questions:</strong> ${s.interview_summary.total_questions}</p>

            ${
              s.interview_summary.summary_text?.strengths
                ? `<p><strong>Strengths:</strong> ${s.interview_summary.summary_text.strengths}</p>`
                : ""
            }
            ${
              s.interview_summary.summary_text?.weaknesses
                ? `<p><strong>Weaknesses:</strong> ${s.interview_summary.summary_text.weaknesses}</p>`
                : ""
            }
            ${
              s.interview_summary.summary_text?.engagement
                ? `<p><strong>Engagement:</strong> ${s.interview_summary.summary_text.engagement}</p>`
                : ""
            }

            <hr>

            <h3>Technical Questions</h3>
            ${
              s.tech_section.length > 0
                ? s.tech_section
                    .map(
                      (q, i) => `
                    <div style="margin-bottom: 12px;">
                      <p><b>Q${i + 1}:</b> ${q.question}</p>
                      <p><b>A${i + 1}:</b> ${q.answer}</p>
                      <p><i>${q.comment || ""}</i></p>
                      <p><b>Score:</b> ${q.score}/5</p>
                    </div>`
                    )
                    .join("")
                : "<p>No technical questions answered.</p>"
            }

            <hr>

            <h3>Overall Performance</h3>
            <p><strong>Average Score:</strong> ${s.overall.average_score}/5</p>
            <p><strong>Rating:</strong> ${s.overall.rating}</p>

            <hr>

            <h3>Recommendations</h3>
            ${
              s.recommendations.length > 0
                ? `<ul>${s.recommendations.map((r) => `<li>${r}</li>`).join("")}</ul>`
                : "<p>No specific recommendations.</p>"
            }

          </div>
        `;

        openSummaryModal(html);
      }



      // Example: append message to chat box
      const chatBox = document.getElementById("chat-box");
      if (chatBox) {
        // Show question (if exists)
        if (data.question) {
          const qDiv = document.createElement("div");
          qDiv.className = "message question";
          qDiv.innerHTML = `<div class="bubble question">${data.question}</div>`;
          chatBox.appendChild(qDiv);

          // üîä Play audio of the question
          micIcon.className = "fas fa-microphone-slash";
          const utterance = new SpeechSynthesisUtterance(data.question);
          utterance.lang = "en-US";
          window.speechSynthesis.speak(utterance);
          utterance.onend = () => {
            startMic();
          };
        }

        // Show answer (if exists)
        if (data.answer) {
          const aDiv = document.createElement("div");
          aDiv.className = "message answer";
          aDiv.innerHTML = `<div class="bubble answer">${data.answer}</div>`;
          chatBox.appendChild(aDiv);
        }

        // Auto scroll
        chatBox.scrollTop = chatBox.scrollHeight;
      }
    };

    socket.onclose = function () {};

    socket.onerror = function (error) {};
  }

  // =======================
  // CONFIG
  // =======================
  let noiseFloor = 0.01;
  let smoothing = 0.95;

  const RELATIVE_FACTOR = 2.2;        // how much louder than noise
  const ABSOLUTE_MIN_RMS = 0.008;     // minimum RMS required to count as voice
  const START_FRAMES = 3;             // must detect 3 frames of speech before start
  const STOP_FRAMES = 80;             // ~1.5 sec depending on 60fps ‚Üí prevents early stop

  // =======================
  // STATE
  // =======================
  let micStream;
  let mediaRecorder;
  let audioChunks = [];
  let audioContext, analyser, dataArray, source;
  let silenceTimer = null;
  let analyzing = false;

  let startCounter = 0;
  let stopCounter = 0;


  // =======================
  // START MIC
  // =======================
  async function startMic() {
    micStream = await navigator.mediaDevices.getUserMedia({ audio: true });

    mediaRecorder = new MediaRecorder(micStream, { mimeType: "audio/webm" });

    mediaRecorder.ondataavailable = (event) => {
      if (event.data.size > 0) audioChunks.push(event.data);
    };

    mediaRecorder.onstop = () => {
      if (audioChunks.length > 0) {
        const audioBlob = new Blob(audioChunks, { type: "audio/webm" });
        audioChunks = [];

        if (socket && socket.readyState === WebSocket.OPEN) {
          console.log("üì§ Sending speech blob to backend...");
          socket.send(audioBlob);
        }
      }

      stopMic();
    };

    // ANALYSER
    audioContext = new AudioContext();
    source = audioContext.createMediaStreamSource(micStream);
    analyser = audioContext.createAnalyser();
    analyser.fftSize = 1024;

    dataArray = new Uint8Array(analyser.fftSize);

    source.connect(analyser);

    analyzing = true;
    detectSpeech();

    document.getElementById("mic-icon").className =
      "fas fa-microphone text-green-500";
  }


  // =======================
  // STOP MIC
  // =======================
  function stopMic() {
    analyzing = false;

    try {
      if (mediaRecorder && mediaRecorder.state === "recording") {
        mediaRecorder.stop();
      }
    } catch (e) {}

    if (micStream) {
      micStream.getTracks().forEach((t) => t.stop());
    }

    if (audioContext) {
      try { audioContext.close(); } catch (e) {}
      audioContext = null;
    }

    if (silenceTimer) clearTimeout(silenceTimer);

    document.getElementById("mic-icon").className =
      "fas fa-microphone-slash text-red-500";
  }


  // =======================
  // STABLE RMS-BASED VAD
  // =======================
  function detectSpeech() {
    if (!analyzing || !analyser) return;

    analyser.getByteTimeDomainData(dataArray);

    // RMS calculation
    let sum = 0;
    for (let i = 0; i < dataArray.length; i++) {
      const v = (dataArray[i] - 128) / 128;
      sum += v * v;
    }
    const rms = Math.sqrt(sum / dataArray.length);

    // Update noise floor only when quiet
    if (rms < noiseFloor * 1.3) {
      noiseFloor = smoothing * noiseFloor + (1 - smoothing) * rms;
    }

    // Dynamic threshold
    const threshold = Math.max(noiseFloor * RELATIVE_FACTOR, ABSOLUTE_MIN_RMS);

    const isSpeech = rms > threshold;

    if (isSpeech) {
      startCounter++;
      stopCounter = 0;

      if (startCounter >= START_FRAMES) {
        if (mediaRecorder.state === "inactive") {
          console.log("üéôÔ∏è Speech detected ‚Üí recording started");
          mediaRecorder.start();
        }

        if (silenceTimer) {
          clearTimeout(silenceTimer);
          silenceTimer = null;
        }
      }
    } else {
      startCounter = 0;
      stopCounter++;

      // Stop only after long silence
      if (stopCounter >= STOP_FRAMES) {
        if (mediaRecorder.state === "recording" && !silenceTimer) {
          silenceTimer = setTimeout(() => {
            console.log("‚èπÔ∏è Silence ‚Üí stop recording");
            mediaRecorder.stop();
          }, 0);
        }
      }
    }

    requestAnimationFrame(detectSpeech);
  }

</script>

<script>
  document.getElementById("summaryModal").addEventListener("click", function(e) {
    if (e.target.id === "summaryModal") {
      // Close the modal if needed
      closeSummaryModal();

      // Redirect to a different page
      window.location.href = "/interview-practice"; 
      // Example: window.location.href = "/dashboard";
    }
  });
</script>

{% endblock content %}
